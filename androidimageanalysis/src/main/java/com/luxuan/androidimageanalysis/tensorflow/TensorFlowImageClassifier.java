package com.luxuan.androidimageanalysis.tensorflow;

import android.content.res.AssetManager;
import android.graphics.Bitmap;
import android.os.Trace;
import android.util.Log;

import org.tensorflow.Operation;
import org.tensorflow.contrib.android.TensorFlowInferenceInterface;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.PriorityQueue;
import java.util.Vector;

public class TensorFlowImageClassifier implements Classifier {

    private static final String TAG="tensorflow";

    private static final int MAX_RESULTS=3;
    private static final float THRESHOLD=0.1f;

    private String inputName;
    private String outputName;
    private int inputSize;
    private int imageMean;
    private float imageStd;

    private Vector<String> labels=new Vector<>();
    private int[] intValues;
    private float[] floatValues;
    private float[] outputs;
    private String[] outputNames;

    private boolean logStats=false;

    private TensorFlowInferenceInterface inferenceInterface;

    private TensorFlowImageClassifier(){

    }

    public static Classifier create(
            AssetManager assetManager,
            String modelFilename,
            String labelFilename,
            int inputSize,
            int imageMean,
            float imageStd,
            String inputName,
            String outputName){
        TensorFlowImageClassifier c=new TensorFlowImageClassifier();
        c.inputName=inputName;
        c.outputName=outputName;

        String actualFilename=labelFilename.split("file:///android_asset/")[1];
        Log.i(TAG, "Reading labels from: "+actualFilename);
        BufferedReader br=null;
        try{
            br=new BufferedReader(new InputStreamReader(assetManager.open(actualFilename)));
            String line;
            while((line=br.readLine())!=null){
                c.labels.add(line);
            }
            br.close();
        }catch(IOException e){
            throw new RuntimeException("Problem reading label file!", e);
        }

        c.inferenceInterface=new TensorFlowInferenceInterface(assetManager, modelFilename);

        final Operation operation =c.inferenceInterface.graphOperation(outputName);
        final int numClasses=(int)operation.output(0).shape().size(1);
        Log.i(TAG, "Read "+c.labels.size()+" labels, output layer size is "+numClasses);

        c.inputSize=inputSize;
        c.imageMean=imageMean;
        c.imageStd=imageStd;

        c.outputNames=new String[]{outputName};
        c.intValues=new int[inputSize*inputSize];
        c.floatValues=new float[inputSize*inputSize*3];
        c.outputs=new float[numClasses];

        return c;
    }

    @Override
    public List<Recognition> recognizeImage(final Bitmap bitmap){
        Trace.beginSection("recognizeImage");

        Trace.beginSection("preprocessBitmap");

        bitmap.getPixels(intValues, 0, bitmap.getWidth(), 0, 0, bitmap.getWidth(), bitmap.getHeight());

        for(int i=0;i<intValues.length;i++){
            final int val=intValues[i];

            floatValues[i*3]=(((val>>16)&0xFF)-imageMean)/imageStd;
            floatValues[i*3+1]=(((val>>8)&0xFF)-imageMean)/imageStd;
            floatValues[i*3+2]=((val&0xFF)-imageMean)/imageStd;
        }

        Trace.endSection();

        Trace.beginSection("feed");
        inferenceInterface.feed(inputName, floatValues, 1, inputSize, inputSize, 3);
        Trace.endSection();

        Trace.beginSection("fetch");
        inferenceInterface.fetch(outputName, outputs);
        Trace.endSection();

        PriorityQueue<Recognition> pq= new PriorityQueue<>(3, new Comparator<Recognition>(){

            @Override
            public int compare(Recognition lhs, Recognition rhs){
                return Float.compare(rhs.getConfidence(), lhs.getConfidence());
            }
        });

        for(int i=0;i<outputs.length;i++){
            if(outputs[i]>THRESHOLD){
                pq.add(new Recognition(""+i, labels.size()>i?labels.get(i):"unknown", outputs[i], null));
            }
        }

        final ArrayList<Recognition> recognitions=new ArrayList<>();
        int recognitionsSize=Math.min(pq.size(), MAX_RESULTS);
        for(int i=0;i<recognitionsSize;i++){
            recognitions.add(pq.poll());
        }

        Trace.endSection();
        return recognitions;
    }

    @Override
    public void enableStatsLogging(boolean logStats){
        this.logStats=logStats;
    }

    @Override
    public String getStatsString(){
        return inferenceInterface.getStatString();
    }

    @Override
    public void close(){
        inferenceInterface.close();
    }

}
